<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Galaxy Preview — Stable IDs & robust</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;cursor:grab}
  canvas{display:block;width:100vw;height:100vh}
  #fullscreenBtn{position:fixed;bottom:15px;right:15px;z-index:10;background:#111a;border:none;border-radius:50%;width:44px;height:44px;display:flex;align-items:center;justify-content:center;cursor:pointer}
  #fullscreenBtn:hover{ background:#333a; }
  #fullscreenBtn svg{ width:22px;height:22px;fill:#fff; }
  #leaveStarBtn{position:fixed;bottom:15px;left:15px;z-index:10;background:#ffd700aa;border:none;border-radius:20px;padding:10px 18px;font-size:14px;font-weight:bold;color:#000;cursor:pointer;box-shadow:0 0 8px #ffd70088}
  #leaveStarBtn:hover{ background:#ffe066; }
  .toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.92); padding: 10px 18px; border-radius: 20px; font-weight:600; box-shadow: 0 6px 18px rgba(0,0,0,0.25); z-index:9999; opacity:0; transition:opacity .25s, transform .25s; transform-origin:center top; }
  .modal-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.45);z-index:200;backdrop-filter: blur(2px);display:none}
  .modal{background:#111;padding:18px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.6);color:#fff;min-width:280px}
  .modal h3{margin:0 0 8px 0;font-size:16px}
  .modal input{width:100%;padding:8px;border-radius:8px;border:1px solid #333;background:#0b0b0b;color:#fff;margin-bottom:10px}
  .modal .buttons{display:flex;gap:8px;justify-content:flex-end}
  .modal button{padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
</style>
</head>
<body>
  <canvas id="c"></canvas>

  <button id="fullscreenBtn" title="Toggle Fullscreen">
    <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zm-3-12v2h3v3h2V5h-5z"/></svg>
  </button>

  <button id="leaveStarBtn">Leave a Star ⭐</button>

  <div id="nameModal" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Leave a Star — enter your name</h3>
      <input id="nameInput" placeholder="Your name" maxlength="40" />
      <div class="buttons">
        <button id="nameCancel">Cancel</button>
        <button id="nameOk">OK</button>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- CONFIG ----------
  const BIN_ID = "68bf1d83ae596e708fe72284"; // your bin id (for remote testing)
  const API_KEY = "$2a$10$ZZmri.xNpvu4cY6Iwt1z0ORO.UqK6oYspAWWzBVC0.zEBxRF3FAay"; // demo only — don't expose in prod
  const JSONBIN_URL = `https://api.jsonbin.io/v3/b/${BIN_ID}`;
  const LOCAL_KEY = 'galaxy.persistedStars.v1';
  const REMOTE_TIMEOUT_MS = 6000; // 6s
  const params = {
    spinSpeed: 0.00018,
    starCount: 1400,
    arms: 3,
    cameraDistanceFactor: 1.6,
    armTightness: 6.2,
    coreHeightFactor: 0.1,
    bgStarCount: 900
  };
  // ----------------------------

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, window.devicePixelRatio || 1);
  let CAMERA_DISTANCE = 1000;
  let stars = [];
  let persistedStars = []; // array of {id:string, name:string}
  let saveTimeout = null;

  function toast(msg){
    const el = document.createElement('div');
    el.className = 'toast';
    el.textContent = msg;
    document.body.appendChild(el);
    requestAnimationFrame(()=>{ el.style.opacity = 1; el.style.transform = 'translateY(0)'; });
    setTimeout(()=>{ el.style.opacity = 0; el.style.transform = 'translateY(-6px)'; setTimeout(()=>el.remove(),280); }, 3000);
  }

  // ---------------- robust fetch with timeout ----------------
  async function fetchWithTimeout(url, opts = {}, timeout = REMOTE_TIMEOUT_MS){
    const ac = new AbortController();
    const id = setTimeout(()=>ac.abort(), timeout);
    try {
      const res = await fetch(url, {...opts, signal: ac.signal});
      clearTimeout(id);
      return res;
    } catch(err){
      clearTimeout(id);
      throw err;
    }
  }

  // ------------- load (local first, then remote merge) -------------
  async function loadStarsFromDB(){
    // local
    try {
      const raw = localStorage.getItem(LOCAL_KEY);
      if(raw){
        const parsed = JSON.parse(raw);
        if(Array.isArray(parsed)) {
          persistedStars = parsed.map(p => ({ id: String(p.id), name: p.name }));
          console.info('Loaded persistedStars from localStorage', persistedStars);
          toast('Loaded saved stars (local)');
        }
      }
    } catch(err){ console.warn('localStorage read error', err); }

    // remote (best-effort, fast-fail)
    try {
      const res = await fetchWithTimeout(JSONBIN_URL + '/latest', {
        headers: { 'X-Master-Key': API_KEY }
      }, REMOTE_TIMEOUT_MS);
      if(!res.ok) throw new Error('HTTP ' + res.status + ' ' + res.statusText);
      const json = await res.json();
      // JSONBin v3 typically returns { record: ... }
      let incoming = null;
      if(Array.isArray(json)) incoming = json;
      else if(json && Array.isArray(json.record)) incoming = json.record;
      else {
        for(const k of Object.keys(json||{})){
          if(Array.isArray(json[k])) { incoming = json[k]; break; }
        }
      }
      if(!incoming) throw new Error('Invalid JSON shape from remote (no array found)');
      incoming = incoming.map(it => ({ id: String(it.id), name: it.name }));
      // Merge: remote overrides local
      const map = new Map();
      (persistedStars || []).forEach(p => map.set(String(p.id), p));
      incoming.forEach(p => map.set(String(p.id), p));
      persistedStars = Array.from(map.values());
      try{ localStorage.setItem(LOCAL_KEY, JSON.stringify(persistedStars)); }catch(e){}
      console.info('Loaded and merged remote persistedStars', persistedStars);
      toast('Loaded saved stars (remote)');
    } catch(err){
      console.warn('Remote load failed:', err);
      if(err.name === 'AbortError') toast('Remote load timed out — using local copies');
      else if(err instanceof TypeError && err.message.includes('Failed to fetch')) toast('Remote load failed (network/CORS) — using local copies');
      else toast('Could not load remote stars — using local copies');
    }
  }

  // ------------- save (local immediate + debounced remote) -------------
  function scheduleSaveStarsToDB(){
    try{ localStorage.setItem(LOCAL_KEY, JSON.stringify(persistedStars)); } catch(e){ console.warn('local save failed', e); }
    if(saveTimeout) clearTimeout(saveTimeout);
    saveTimeout = setTimeout(() => saveStarsToDB().catch(() => {}), 400);
  }

  async function saveStarsToDB(){
    try {
      const res = await fetchWithTimeout(JSONBIN_URL, {
        method: 'PUT',
        headers: {'Content-Type':'application/json','X-Master-Key':API_KEY},
        body: JSON.stringify(persistedStars)
      }, REMOTE_TIMEOUT_MS);
      if(!res.ok) throw new Error('HTTP ' + res.status);
      toast('Saved to remote');
      console.info('Remote save OK');
    } catch(err){
      console.warn('Remote save failed:', err);
      if(err.name === 'AbortError') toast('Remote save timed out — saved locally');
      else if(err instanceof TypeError && err.message.includes('Failed to fetch')) toast('Remote save failed (network/CORS) — saved locally');
      else toast('Remote save failed — saved locally');
    }
  }

  // ----------------- geometry generation -----------------
  function resize(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    const W = innerWidth, H = innerHeight;
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    CAMERA_DISTANCE = Math.max(W, H) * params.cameraDistanceFactor;
    regenerate();
  }
  addEventListener('resize', resize);
  resize();

  function regenerate(){
    stars = [];
    const W = innerWidth, H = innerHeight;
    const R = Math.hypot(W/2, H/2);

    // Spiral stars — deterministic IDs (based on index) so persisted names map correctly
    for(let i=0;i<params.starCount;i++){
      const arm = i % params.arms;
      const armAngle = (arm / params.arms) * Math.PI*2;
      const t = Math.random() * R * 0.85;
      const armOffset = -(t / R) * params.armTightness * Math.PI;
      const theta = armAngle + armOffset + (Math.random()-0.5)*0.15;
      const spread = Math.random() * 14 * (1 - t/R);

      const baseX = Math.cos(theta) * t + (Math.random()-0.5) * spread;
      const baseY = Math.sin(theta) * t + (Math.random()-0.5) * spread * 0.6;
      const baseZ = (Math.random() - 0.5) * Math.max(60, window.innerWidth*0.08) * params.coreHeightFactor;

      // ensure positive sizes
      let size;
      if (Math.random() < 0.65) {
        size = Math.max(0.6, (1 - t / R) * 2.8);
      } else {
        size = Math.max(0.3, (1 - t / R) * 1.5);
      }

      // deterministic ID
      const id = `spiral-${i}`;

      let color;
      if (Math.random() < 0.65) {
        const r = 120 + Math.floor(Math.random() * 60);
        const g = 120 + Math.floor(Math.random() * 60);
        const b = 180 + Math.floor(Math.random() * 40);
        const alpha = 0.6 + Math.random() * 0.4;
        color = `rgba(${r},${g},${b},${alpha.toFixed(3)})`;
      } else {
        const r = 200 + Math.floor(Math.random() * 55);
        const g = 200 + Math.floor(Math.random() * 55);
        const b = 230 + Math.floor(Math.random() * 25);
        const alpha = 0.35 + Math.random() * 0.45;
        color = `rgba(${r},${g},${b},${alpha.toFixed(3)})`;
      }

      stars.push({
        id: String(id),
        angle: theta,
        radius: t,
        x: baseX,
        y: baseY,
        z: baseZ,
        size: Math.abs(size),
        color,
        arm,
        twinkle:false,
        name:null,
        burst:false,
        burstStart:0
      });
    }

    // Background stars — deterministic ids based on index
    for(let i=0;i<params.bgStarCount;i++){
      const radius = Math.random() * R * 1.3;
      const angle = Math.random() * Math.PI * 2;
      const z = (Math.random() - 0.5) * Math.max(120, innerWidth*0.15);
      const size = Math.max(0.25, 0.4 + Math.random() * 0.8);
      const palette = [[220,220,255],[255,255,255],[255,245,200],[200,220,255]];
      const c = palette[Math.floor(Math.random()*palette.length)];
      const baseAlpha = 0.45 + Math.random() * 0.45;
      const twinklePhase = Math.random() * Math.PI*2;
      const twinkleSpeed = 0.001 + Math.random() * 0.002;
      const id = `bg-${i}`;
      stars.push({
        id: String(id),
        angle, radius, x:0, y:0, z,
        size: Math.abs(size),
        color:[c[0],c[1],c[2]],
        baseAlpha, twinkle:true,
        twinklePhase, twinkleSpeed,
        name:null, burst:false, burstStart:0
      });
    }

    // Ensure names from persistedStars apply
    applyPersistedNames();
  }

  function applyPersistedNames(){
    if(!Array.isArray(persistedStars)) return;
    const map = new Map(persistedStars.map(p => [String(p.id), p]));
    for(const s of stars){
      if(map.has(String(s.id))){
        s.name = map.get(String(s.id)).name;
      }
    }
  }

  // --------------- camera & interactions ---------------
  let camRotX = -1.200, camRotY = 2.810, isPointerDown=false, lastX=0,lastY=0;
  canvas.addEventListener('pointerdown', (e)=>{ isPointerDown=true; lastX=e.clientX; lastY=e.clientY; try{canvas.setPointerCapture(e.pointerId)}catch(e){}; canvas.style.cursor='grabbing';});
  canvas.addEventListener('pointerup', (e)=>{ isPointerDown=false; try{canvas.releasePointerCapture(e.pointerId)}catch(e){}; canvas.style.cursor='grab';});
  canvas.addEventListener('pointercancel', ()=>{ isPointerDown=false; canvas.style.cursor='grab'; });
  canvas.addEventListener('pointermove', (e)=>{ if(!isPointerDown) return; const dx = e.clientX - lastX, dy = e.clientY - lastY; lastX = e.clientX; lastY = e.clientY; camRotY += dx * 0.005; camRotX += dy * 0.005; camRotX = Math.max(-1.2, Math.min(1.2, camRotX)); });

  // fullscreen button
  document.getElementById('fullscreenBtn').addEventListener('click', ()=>{ if(!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{}); else document.exitFullscreen().catch(()=>{}); });

  // -------------- leave star modal --------------
  const nameModal = document.getElementById('nameModal');
  const nameInput = document.getElementById('nameInput');
  const nameOk = document.getElementById('nameOk') || document.getElementById('nameOk'); // fallback
  const nameCancel = document.getElementById('nameCancel');

  function openNameModal(){ nameInput.value=''; nameModal.style.display='flex'; nameModal.setAttribute('aria-hidden','false'); setTimeout(()=> nameInput.focus(),60); }
  function closeNameModal(){ nameModal.style.display='none'; nameModal.setAttribute('aria-hidden','true'); }

  document.getElementById('leaveStarBtn').addEventListener('click', ()=> openNameModal());
  nameCancel.addEventListener('click', ()=> closeNameModal());
  nameInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') onNameOk(); });
  nameOk.addEventListener('click', onNameOk);

  function onNameOk(){
    const name = (nameInput.value || '').trim();
    if(!name){ toast('Name cannot be empty'); return; }
    closeNameModal();
    try {
      const candidates = stars.filter(s => !s.twinkle && !s.name);
      if(candidates.length === 0){ toast('No available stars'); return; }
      const chosen = candidates[Math.floor(Math.random()*candidates.length)];
      chosen.name = name;
      chosen.burst = true;
      chosen.burstStart = performance.now();
      // update persistedStars record (id as string)
      const idx = persistedStars.findIndex(ps => String(ps.id) === String(chosen.id));
      if(idx !== -1) persistedStars[idx].name = name;
      else persistedStars.push({ id: String(chosen.id), name });
      scheduleSaveStarsToDB();
    } catch(err){
      console.error('assign name failed', err);
      toast('Failed to assign name');
    }
  }

  // --------------- drawing ---------------
  let last = performance.now();
  function draw(now){
    try{
      const dt = now - last; last = now;
      const W = innerWidth, H = innerHeight;
      ctx.clearRect(0,0,W,H);
      ctx.save(); ctx.translate(W/2, H/2);
      const cosX = Math.cos(camRotX), sinX = Math.sin(camRotX), cosY = Math.cos(camRotY), sinY = Math.sin(camRotY);

      for(const s of stars){
        try{
          s.angle += params.spinSpeed * dt * (0.5 + (s.radius || 0) * 0.0005);
          const x = Math.cos(s.angle) * s.radius;
          const y = Math.sin(s.angle) * s.radius;
          let z = s.z || 0;
          let rx = cosY * x + sinY * z;
          let rz = -sinY * x + cosY * z;
          let ry = cosX * y - sinX * rz;
          rz = sinX * y + cosX * rz;
          const denom = Math.max(120, CAMERA_DISTANCE + rz);
          const proj = CAMERA_DISTANCE / denom;
          const sx = rx * proj, sy = ry * proj;
          // ensure positive and non-zero values for arc radius
          const safeSize = Math.abs(s.size || 0.5);
          const screenR = Math.max(0.15, safeSize * Math.max(0.001, proj));

          let fillStyle;
          if(s.twinkle && Array.isArray(s.color)){
            const twinkle = 0.4 + 0.6 * Math.abs(Math.sin((s.twinklePhase||0) + now * (s.twinkleSpeed||0.001)));
            const alpha = Math.min(1, (s.baseAlpha||0.6) * twinkle);
            fillStyle = `rgba(${s.color[0]},${s.color[1]},${s.color[2]},${alpha.toFixed(3)})`;
          } else fillStyle = s.color || 'rgba(220,220,255,0.8)';

          if(s.burst){
            const elapsed = now - s.burstStart;
            if(elapsed < 1500){ 
              const pulse = 1 + 1.5 * Math.sin(elapsed/100 * Math.PI/6);
              ctx.beginPath(); ctx.fillStyle = "rgba(255,215,0,0.95)"; ctx.arc(sx, sy, Math.max(0.15, screenR * pulse), 0, Math.PI*2); ctx.fill();
            } else {
              s.burst = false;
              ctx.beginPath(); ctx.fillStyle = fillStyle; ctx.arc(sx, sy, screenR, 0, Math.PI*2); ctx.fill();
            }
          } else {
            ctx.beginPath(); ctx.fillStyle = fillStyle; ctx.arc(sx, sy, screenR, 0, Math.PI*2); ctx.fill();
          }

          if(s.name){
            ctx.fillStyle = "#fff"; ctx.font = "bold 12px sans-serif"; ctx.textAlign = "center";
            ctx.fillText(s.name, sx, sy - Math.max(8, screenR*2));
          }
        }catch(err){ console.warn('star draw error', err); }
      }

      // core
      const coreRadius = 22;
      const gradient = ctx.createRadialGradient(0,0,0,0,0,coreRadius*6);
      gradient.addColorStop(0,'rgba(255,255,220,1)'); gradient.addColorStop(0.3,'rgba(255,220,180,0.6)'); gradient.addColorStop(1,'rgba(255,200,200,0)');
      ctx.beginPath(); ctx.fillStyle = gradient; ctx.arc(0,0, coreRadius*6, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,240,0.95)'; ctx.arc(0,0, coreRadius, 0, Math.PI*2); ctx.fill();

      ctx.restore();
    }catch(err){
      console.error('draw loop error', err);
    } finally {
      requestAnimationFrame(draw);
    }
  }

  // ---------- init ----------
  (async function init(){
    await loadStarsFromDB();   // loads persistedStars (local + remote merge)
    regenerate();              // generate stars (deterministic IDs)
    applyPersistedNames();     // ensure names are applied (should already be done in regenerate but safe)
    requestAnimationFrame(draw);
  })();

})();
</script>
</body>
</html>
