<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Galaxy Preview â€” Remote Storage Only</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden;cursor:grab}
  canvas{display:block;width:100vw;height:100vh}
  #fullscreenBtn, #leaveStarBtn, #friendsBtn, #syncBtn, #toggleNamesBtn{position:fixed;z-index:10;background:#111a;border:none;border-radius:50%;width:44px;height:44px;display:flex;align-items:center;justify-content:center;cursor:pointer}
  #fullscreenBtn:hover, #leaveStarBtn:hover, #friendsBtn:hover, #syncBtn:hover, #toggleNamesBtn:hover{ background:#333a; }
  #fullscreenBtn svg, #leaveStarBtn svg, #friendsBtn svg, #syncBtn svg, #toggleNamesBtn svg{ width:22px;height:22px;fill:#fff; }
  #fullscreenBtn{bottom:15px;right:15px;}
  #leaveStarBtn{bottom:70px;right:15px;width:auto;border-radius:20px;padding:0 15px;gap:8px;}
  #leaveStarBtn span{color:#fff;font-size:14px;font-weight:500;}
  #friendsBtn{top:15px;right:15px;}
  #syncBtn{top:70px;right:15px;}
  #toggleNamesBtn{top:125px;right:15px;}
  .toast { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.92); padding: 10px 18px; border-radius: 20px; font-weight:600; box-shadow: 0 6px 18px rgba(0,0,0,0.25); z-index:9999; opacity:0; transition:opacity .25s, transform .25s; transform-origin:center top; }
  .modal-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.85);z-index:200;backdrop-filter: blur(4px);display:none}
  .modal{background:#222;padding:24px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.8);color:#fff;min-width:300px;border:1px solid #444}
  .modal h3{margin:0 0 16px 0;font-size:18px;text-align:center;color:#fff}
  .modal input{width:100%;padding:12px;border-radius:8px;border:1px solid #444;background:#1a1a1a;color:#fff;margin-bottom:16px;font-size:16px;box-sizing:border-box}
  .modal input:focus{outline:none;border-color:#666}
  .modal .buttons{display:flex;gap:10px;justify-content:center}
  .modal button{padding:10px 20px;border-radius:8px;border:none;cursor:pointer;font-weight:600;transition:background .2s}
  #nameCancel{background:#444;color:#fff}
  #nameCancel:hover{background:#555}
  #nameOk{background:#2d7dff;color:#fff}
  #nameOk:hover{background:#3d8dff}
  #friendsModal .modal{max-width:400px;max-height:70vh;overflow-y:auto}
  .friend-item{padding:10px;border-bottom:1px solid #333;display:flex;justify-content:space-between}
  .friend-item:last-child{border-bottom:none}
  .friend-name{font-weight:500}
  .friend-id{color:#888;font-size:12px}
  .no-friends{padding:20px;text-align:center;color:#888}
  .sync-spinner {
    animation: spin 1s linear infinite;
    display: none;
  }
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
</style>
</head>
<body>
  <canvas id="c"></canvas>

  <button id="fullscreenBtn" title="Toggle Fullscreen">
    <svg viewBox="0 0 24 24"><path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zm-3-12v2h3v3h2V5h-5z"/></svg>
  </button>

  <button id="leaveStarBtn" title="Leave a Star">
    <svg viewBox="0 0 24 24"><path d="M12 17.27L18.18 21l-1.64-7.03L22 9.24l-7.19-.61L12 2 9.19 8.63 2 9.24l5.46 4.73L5.82 21z"/></svg>
    <span>Leave a Star</span>
  </button>

  <button id="friendsBtn" title="View All Stars">
    <svg viewBox="0 0 24 24"><path d="M16 11c1.66 0 2.99-1.34 2.99-3S17.66 5 16 5c-1.66 0-3 1.34-3 3s1.34 3 3 3zm-8 0c1.66 0 2.99-1.34 2.99-3S9.66 5 8 5C6.34 5 5 6.34 5 8s1.34 3 3 3zm0 2c-2.33 0-7 1.17-7 3.5V19h14v-2.5c0-2.33-4.67-3.5-7-3.5zm8 0c-.29 0-.62.02-.97.05 1.16.84 1.97 1.97 1.97 3.45V19h6v-2.5c0-2.33-4.67-3.5-7-3.5z"/></svg>
  </button>

  <button id="syncBtn" title="Sync with Server">
    <svg class="sync-spinner" viewBox="0 0 24 24"><path d="M12 4V1L8 5l4 4V6c3.31 0 6 2.69 6 6 0 1.01-.25 1.97-.7 2.8l1.46 1.46C19.54 15.03 20 13.57 20 12c0-4.42-3.58-8-8-8zm0 14c-3.31 0-6-2.69-6-6 0-1.01.25-1.97.7-2.8L5.24 7.74C4.46 8.97 4 10.43 4 12c0 4.42 3.58 8 8 8v3l4-4-4-4v3z"/></svg>
    <svg class="sync-icon" viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
  </button>

  <button id="toggleNamesBtn" title="Toggle Names">
    <svg viewBox="0 0 24 24"><path d="M20 4H4c-1.1 0-1.99.9-1.99 2L2 18c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V6c0-1.1-.9-2-2-2zm-5 14H4v-6h11v6zm5 0h-3v-6h3v6zm0-8H4V6h16v4z"/></svg>
  </button>

  <div id="nameModal" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Name Your Star</h3>
      <input id="nameInput" placeholder="Enter your name" maxlength="40" />
      <div class="buttons">
        <button id="nameCancel">Cancel</button>
        <button id="nameOk">Create Star</button>
      </div>
    </div>
  </div>

  <div id="friendsModal" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Named Stars</h3>
      <div id="friendsList"></div>
    </div>
  </div>

<script>
(() => {
  // ---------- CONFIG ----------
  const BIN_ID = "68bf25c8d0ea881f40765eed";
  const API_KEY = "$2a$10$ZZmri.xNpvu4cY6Iwt1z0ORO.UqK6oYspAWWzBVC0.zEBxRF3FAay";
  const JSONBIN_URL = `https://api.jsonbin.io/v3/b/${BIN_ID}`;
  const REMOTE_TIMEOUT_MS = 6000;
  const params = {
    spinSpeed: 0.00018,
    starCount: 1400,
    arms: 3,
    cameraDistanceFactor: 1.6,
    armTightness: 6.2,
    coreHeightFactor: 0.1,
    bgStarCount: 900
  };
  // ----------------------------

  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, window.devicePixelRatio || 1);
  let CAMERA_DISTANCE = 1000;
  let stars = [];
  let persistedStars = [];
  let saveTimeout = null;
  let showNames = true; // Toggle for showing names

  function toast(msg){
    const el = document.createElement('div');
    el.className = 'toast';
    el.textContent = msg;
    document.body.appendChild(el);
    requestAnimationFrame(()=>{ el.style.opacity = 1; el.style.transform = 'translateY(0)'; });
    setTimeout(()=>{ el.style.opacity = 0; el.style.transform = 'translateY(-6px)'; setTimeout(()=>el.remove(),280); }, 3000);
  }

  // ---------------- robust fetch with timeout ----------------
  async function fetchWithTimeout(url, opts = {}, timeout = REMOTE_TIMEOUT_MS){
    const ac = new AbortController();
    const id = setTimeout(()=>ac.abort(), timeout);
    try {
      const res = await fetch(url, {...opts, signal: ac.signal});
      clearTimeout(id);
      return res;
    } catch(err){
      clearTimeout(id);
      throw err;
    }
  }

  // ------------- load from remote only -------------
  async function loadStarsFromDB(){
    // Show loading state
    document.querySelector('.sync-icon').style.display = 'none';
    document.querySelector('.sync-spinner').style.display = 'block';
    
    try {
      const res = await fetchWithTimeout(JSONBIN_URL + '/latest', {
        headers: { 'X-Master-Key': API_KEY }
      }, REMOTE_TIMEOUT_MS);
      
      if(!res.ok) throw new Error('HTTP ' + res.status);
      
      const json = await res.json();
      let incoming = null;
      if(Array.isArray(json)) incoming = json;
      else if(json && Array.isArray(json.record)) incoming = json.record;
      else {
        for(const k of Object.keys(json||{})){
          if(Array.isArray(json[k])) { incoming = json[k]; break; }
        }
      }
      
      if(!incoming) throw new Error('Invalid JSON shape from remote');
      
      persistedStars = incoming.map(it => ({ id: String(it.id), name: it.name }));
      console.info('Loaded remote persistedStars', persistedStars);
      
    } catch(err){
      console.warn('Remote load failed:', err);
    } finally {
      // Restore sync icon
      document.querySelector('.sync-icon').style.display = 'block';
      document.querySelector('.sync-spinner').style.display = 'none';
    }
  }

  // ------------- save to remote only -------------
  async function saveStarsToDB(){
    // Show loading state
    document.querySelector('.sync-icon').style.display = 'none';
    document.querySelector('.sync-spinner').style.display = 'block';
    
    try {
      const res = await fetchWithTimeout(JSONBIN_URL, {
        method: 'PUT',
        headers: {'Content-Type':'application/json','X-Master-Key':API_KEY},
        body: JSON.stringify(persistedStars)
      }, REMOTE_TIMEOUT_MS);
      
      if(!res.ok) throw new Error('HTTP ' + res.status);
      
      console.info('Remote save OK');
    } catch(err){
      console.warn('Remote save failed:', err);
    } finally {
      // Restore sync icon
      document.querySelector('.sync-icon').style.display = 'block';
      document.querySelector('.sync-spinner').style.display = 'none';
    }
  }

  // ----------------- geometry generation -----------------
  function resize(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    const W = innerWidth, H = innerHeight;
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);
    CAMERA_DISTANCE = Math.max(W, H) * params.cameraDistanceFactor;
    regenerate();
  }
  addEventListener('resize', resize);
  resize();

  function regenerate(){
    stars = [];
    const W = innerWidth, H = innerHeight;
    const R = Math.hypot(W/2, H/2);

    // Spiral stars
    for(let i=0;i<params.starCount;i++){
      const arm = i % params.arms;
      const armAngle = (arm / params.arms) * Math.PI*2;
      const t = Math.random() * R * 0.85;
      const armOffset = -(t / R) * params.armTightness * Math.PI;
      const theta = armAngle + armOffset + (Math.random()-0.5)*0.15;
      const spread = Math.random() * 14 * (1 - t/R);

      const baseX = Math.cos(theta) * t + (Math.random()-0.5) * spread;
      const baseY = Math.sin(theta) * t + (Math.random()-0.5) * spread * 0.6;
      const baseZ = (Math.random() - 0.5) * Math.max(60, window.innerWidth*0.08) * params.coreHeightFactor;

      let size;
      if (Math.random() < 0.65) {
        size = Math.max(0.6, (1 - t / R) * 2.8);
      } else {
        size = Math.max(0.3, (1 - t / R) * 1.5);
      }

      const id = `spiral-${i}`;

      let color;
      if (Math.random() < 0.65) {
        const r = 120 + Math.floor(Math.random() * 60);
        const g = 120 + Math.floor(Math.random() * 60);
        const b = 180 + Math.floor(Math.random() * 40);
        const alpha = 0.6 + Math.random() * 0.4;
        color = `rgba(${r},${g},${b},${alpha.toFixed(3)})`;
      } else {
        const r = 200 + Math.floor(Math.random() * 55);
        const g = 200 + Math.floor(Math.random() * 55);
        const b = 230 + Math.floor(Math.random() * 25);
        const alpha = 0.35 + Math.random() * 0.45;
        color = `rgba(${r},${g},${b},${alpha.toFixed(3)})`;
      }

      stars.push({
        id: String(id),
        angle: theta,
        radius: t,
        x: baseX,
        y: baseY,
        z: baseZ,
        size: Math.abs(size),
        color,
        arm,
        twinkle:false,
        name:null,
        burst:false,
        burstStart:0
      });
    }

    // Background stars
    for(let i=0;i<params.bgStarCount;i++){
      const radius = Math.random() * R * 1.3;
      const angle = Math.random() * Math.PI * 2;
      const z = (Math.random() - 0.5) * Math.max(120, innerWidth*0.15);
      const size = Math.max(0.25, 0.4 + Math.random() * 0.8);
      const palette = [[220,220,255],[255,255,255],[255,245,200],[200,220,255]];
      const c = palette[Math.floor(Math.random()*palette.length)];
      const baseAlpha = 0.45 + Math.random() * 0.45;
      const twinklePhase = Math.random() * Math.PI*2;
      const twinkleSpeed = 0.001 + Math.random() * 0.002;
      const id = `bg-${i}`;
      stars.push({
        id: String(id),
        angle, radius, x:0, y:0, z,
        size: Math.abs(size),
        color:[c[0],c[1],c[2]],
        baseAlpha, twinkle:true,
        twinklePhase, twinkleSpeed,
        name:null, burst:false, burstStart:0
      });
    }

    applyPersistedNames();
  }

  function applyPersistedNames(){
    if(!Array.isArray(persistedStars)) return;
    const map = new Map(persistedStars.map(p => [String(p.id), p]));
    for(const s of stars){
      if(map.has(String(s.id))){
        s.name = map.get(String(s.id)).name;
      }
    }
  }

  // --------------- camera & interactions ---------------
  let camRotX = -1.200, camRotY = 2.810, isPointerDown=false, lastX=0,lastY=0;
  canvas.addEventListener('pointerdown', (e)=>{ isPointerDown=true; lastX=e.clientX; lastY=e.clientY; try{canvas.setPointerCapture(e.pointerId)}catch(e){}; canvas.style.cursor='grabbing';});
  canvas.addEventListener('pointerup', (e)=>{ isPointerDown=false; try{canvas.releasePointerCapture(e.pointerId)}catch(e){}; canvas.style.cursor='grab';});
  canvas.addEventListener('pointercancel', ()=>{ isPointerDown=false; canvas.style.cursor='grab'; });
  canvas.addEventListener('pointermove', (e)=>{ if(!isPointerDown) return; const dx = e.clientX - lastX, dy = e.clientY - lastY; lastX = e.clientX; lastY = e.clientY; camRotY += dx * 0.005; camRotX += dy * 0.005; camRotX = Math.max(-1.2, Math.min(1.2, camRotX)); });

  // fullscreen button
  document.getElementById('fullscreenBtn').addEventListener('click', ()=>{ if(!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{}); else document.exitFullscreen().catch(()=>{}); });

  // sync button
  document.getElementById('syncBtn').addEventListener('click', async ()=>{ 
    await loadStarsFromDB();
    applyPersistedNames();
  });

  // toggle names button
  document.getElementById('toggleNamesBtn').addEventListener('click', ()=>{ 
    showNames = !showNames;
    
  });

  // -------------- leave star modal --------------
  const nameModal = document.getElementById('nameModal');
  const nameInput = document.getElementById('nameInput');
  const nameOk = document.getElementById('nameOk');
  const nameCancel = document.getElementById('nameCancel');

  function openNameModal(){ nameInput.value=''; nameModal.style.display='flex'; nameModal.setAttribute('aria-hidden','false'); setTimeout(()=> nameInput.focus(),60); }
  function closeNameModal(){ nameModal.style.display='none'; nameModal.setAttribute('aria-hidden','true'); }

  document.getElementById('leaveStarBtn').addEventListener('click', ()=> openNameModal());
  nameCancel.addEventListener('click', ()=> closeNameModal());
  nameInput.addEventListener('keydown', (e)=>{ if(e.key==='Enter') onNameOk(); });
  nameOk.addEventListener('click', onNameOk);

  function onNameOk(){
    const name = (nameInput.value || '').trim();
    if(!name){ toast('Name cannot be empty'); return; }
    closeNameModal();
    try {
      const candidates = stars.filter(s => !s.twinkle && !s.name);
      if(candidates.length === 0){ toast('No available stars'); return; }
      const chosen = candidates[Math.floor(Math.random()*candidates.length)];
      chosen.name = name;
      chosen.burst = true;
      chosen.burstStart = performance.now();
      const idx = persistedStars.findIndex(ps => String(ps.id) === String(chosen.id));
      if(idx !== -1) persistedStars[idx].name = name;
      else persistedStars.push({ id: String(chosen.id), name });
      saveStarsToDB();
      toast('Star created!');
    } catch(err){
      console.error('assign name failed', err);
      toast('Failed to assign name');
    }
  }

  // -------------- friends list modal --------------
  const friendsModal = document.getElementById('friendsModal');
  const friendsList = document.getElementById('friendsList');
  
  document.getElementById('friendsBtn').addEventListener('click', () => {
    updateFriendsList();
    friendsModal.style.display = 'flex';
    friendsModal.setAttribute('aria-hidden', 'false');
  });
  
  function updateFriendsList() {
    if (persistedStars.length === 0) {
      friendsList.innerHTML = '<div class="no-friends">No stars have been named yet</div>';
      return;
    }
    
    let html = '';
    persistedStars.forEach(star => {
      html += `
        <div class="friend-item">
          <span class="friend-name">${star.name}</span>
          <span class="friend-id">#${star.id.substring(0, 8)}</span>
        </div>
      `;
    });
    friendsList.innerHTML = html;
  }
  
  // Close modals when clicking outside
  document.querySelectorAll('.modal-overlay').forEach(overlay => {
    overlay.addEventListener('click', (e) => {
      if (e.target === overlay) {
        overlay.style.display = 'none';
        overlay.setAttribute('aria-hidden', 'true');
      }
    });
  });

  // --------------- drawing ---------------
  let last = performance.now();
  function draw(now){
    try{
      const dt = now - last; last = now;
      const W = innerWidth, H = innerHeight;
      ctx.clearRect(0,0,W,H);
      ctx.save(); ctx.translate(W/2, H/2);
      const cosX = Math.cos(camRotX), sinX = Math.sin(camRotX), cosY = Math.cos(camRotY), sinY = Math.sin(camRotY);

      for(const s of stars){
        try{
          s.angle += params.spinSpeed * dt * (0.5 + (s.radius || 0) * 0.0005);
          const x = Math.cos(s.angle) * s.radius;
          const y = Math.sin(s.angle) * s.radius;
          let z = s.z || 0;
          let rx = cosY * x + sinY * z;
          let rz = -sinY * x + cosY * z;
          let ry = cosX * y - sinX * rz;
          rz = sinX * y + cosX * rz;
          const denom = Math.max(120, CAMERA_DISTANCE + rz);
          const proj = CAMERA_DISTANCE / denom;
          const sx = rx * proj, sy = ry * proj;
          const safeSize = Math.abs(s.size || 0.5);
          const screenR = Math.max(0.15, safeSize * Math.max(0.001, proj));

          let fillStyle;
          if(s.twinkle && Array.isArray(s.color)){
            const twinkle = 0.4 + 0.6 * Math.abs(Math.sin((s.twinklePhase||0) + now * (s.twinkleSpeed||0.001)));
            const alpha = Math.min(1, (s.baseAlpha||0.6) * twinkle);
            fillStyle = `rgba(${s.color[0]},${s.color[1]},${s.color[2]},${alpha.toFixed(3)})`;
          } else fillStyle = s.color || 'rgba(220,220,255,0.8)';

          if(s.burst){
            const elapsed = now - s.burstStart;
            if(elapsed < 1500){ 
              const pulse = 1 + 1.5 * Math.sin(elapsed/100 * Math.PI/6);
              ctx.beginPath(); ctx.fillStyle = "rgba(255,215,0,0.95)"; ctx.arc(sx, sy, Math.max(0.15, screenR * pulse), 0, Math.PI*2); ctx.fill();
            } else {
              s.burst = false;
              ctx.beginPath(); ctx.fillStyle = fillStyle; ctx.arc(sx, sy, screenR, 0, Math.PI*2); ctx.fill();
            }
          } else {
            ctx.beginPath(); ctx.fillStyle = fillStyle; ctx.arc(sx, sy, screenR, 0, Math.PI*2); ctx.fill();
          }

          if(s.name && showNames){
            ctx.fillStyle = "#fff"; ctx.font = "bold 12px sans-serif"; ctx.textAlign = "center";
            ctx.fillText(s.name, sx, sy - Math.max(8, screenR*2));
          }
        }catch(err){ console.warn('star draw error', err); }
      }

      // core
      const coreRadius = 22;
      const gradient = ctx.createRadialGradient(0,0,0,0,0,coreRadius*6);
      gradient.addColorStop(0,'rgba(255,255,220,1)'); gradient.addColorStop(0.3,'rgba(255,220,180,0.6)'); gradient.addColorStop(1,'rgba(255,200,200,0)');
      ctx.beginPath(); ctx.fillStyle = gradient; ctx.arc(0,0, coreRadius*6, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.fillStyle = 'rgba(255,255,240,0.95)'; ctx.arc(0,0, coreRadius, 0, Math.PI*2); ctx.fill();

      ctx.restore();
    }catch(err){
      console.error('draw loop error', err);
    } finally {
      requestAnimationFrame(draw);
    }
  }

  // ---------- init ----------
  (async function init(){
    await loadStarsFromDB();
    regenerate();
    applyPersistedNames();
    requestAnimationFrame(draw);
  })();

})();
</script>
</body>
</html>
