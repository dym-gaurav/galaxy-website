<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Galaxy Preview</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden;cursor:grab}
    canvas{display:block;width:100vw;height:100vh}
    #controls{
      position:fixed;top:10px;left:10px;z-index:10;
      background:#111a;padding:8px 12px;border-radius:8px;
      color:#fff;font-family:sans-serif;
    }
    button{
      background:#333;color:#fff;border:none;
      padding:6px 12px;border-radius:6px;cursor:pointer;
    }
    button:hover{background:#555}
  </style>
</head>
<body>
  <div id="controls">
    <button id="toggle">Mode: Spiral Spin</button>
  </div>
  <canvas id="c"></canvas>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, window.devicePixelRatio || 1);

  const params = {
    spinSpeed: 0.00018,
    starCount: 1800,
    arms: 3,
    cameraDistanceFactor: 1.6,
    armTightness: 6.2,
    coreHeightFactor: 0.1 // <--- NEW: thinner vertical spread around core
  };

  let CAMERA_DISTANCE = 1000;
  let stars = [];

  function resize(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    const W = innerWidth, H = innerHeight;
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);

    CAMERA_DISTANCE = Math.max(W, H) * params.cameraDistanceFactor;
    regenerate();
  }
  addEventListener('resize', resize);
  resize();

  function regenerate(){
    stars = [];
    const W = innerWidth, H = innerHeight;
    const R = Math.hypot(W/2, H/2);

    // Spiral arm stars
    for(let i=0;i<params.starCount;i++){
      const arm = i % params.arms;
      const armAngle = (arm / params.arms) * Math.PI*2;
      const t = Math.random() * R * 0.85;
      const armOffset = -(t / R) * params.armTightness * Math.PI;
      const theta = armAngle + armOffset + (Math.random()-0.5)*0.15;
      const spread = Math.random() * 14 * (1 - t/R);

      const baseX = Math.cos(theta) * t + (Math.random()-0.5) * spread;
      const baseY = Math.sin(theta) * t + (Math.random()-0.5) * spread * 0.6;

      // thinner height near core
      const baseZ = (Math.random() - 0.5) * Math.max(60, W*0.08) * params.coreHeightFactor;

      let size, color;
      if (Math.random() < 0.65) { 
        size = Math.max(0.6, (1 - t / R) * 2.8);
        const r = 120 + Math.floor(Math.random() * 60);
        const g = 120 + Math.floor(Math.random() * 60);
        const b = 180 + Math.floor(Math.random() * 40);
        const alpha = 0.6 + Math.random() * 0.4;
        color = `rgba(${r},${g},${b},${alpha.toFixed(3)})`;
      } else {
        size = Math.max(0.3, (1 - t / R) * 1.5);
        const r = 200 + Math.floor(Math.random() * 55);
        const g = 200 + Math.floor(Math.random() * 55);
        const b = 230 + Math.floor(Math.random() * 25);
        const alpha = 0.35 + Math.random() * 0.45;
        color = `rgba(${r},${g},${b},${alpha.toFixed(3)})`;
      }

      stars.push({ angle: theta, radius: t, x: baseX, y: baseY, z: baseZ, size, color, arm });
    }

    // Background stars (filler)
    const bgCount = Math.floor(params.starCount * 0.8);
    for(let i=0;i<bgCount;i++){
      const radius = Math.random() * R * 1.3;
      const angle = Math.random() * Math.PI * 2;
      const z = (Math.random() - 0.5) * Math.max(120, W*0.15); // keep filler thick

      const size = 0.4 + Math.random() * 0.8;  
      const palette = [
        [220,220,255],
        [255,255,255],
        [255,245,200],
        [200,220,255]
      ];
      const c = palette[Math.floor(Math.random()*palette.length)];
      const alpha = 0.45 + Math.random() * 0.45;
      const color = `rgba(${c[0]},${c[1]},${c[2]},${alpha.toFixed(3)})`;

      stars.push({ angle, radius, x:0, y:0, z, size, color, arm:-1 });
    }
  }

  let camRotX = -1.200;
  let camRotY = 2.810;
  let isPointerDown = false;
  let lastX = 0, lastY = 0;

  canvas.addEventListener('pointerdown', (e) => {
    isPointerDown = true;
    lastX = e.clientX; lastY = e.clientY;
    canvas.setPointerCapture(e.pointerId);
    canvas.style.cursor = 'grabbing';
  });
  canvas.addEventListener('pointerup', (e) => {
    isPointerDown = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch(e){}
    canvas.style.cursor = 'grab';
  });
  canvas.addEventListener('pointercancel', () => { isPointerDown = false; canvas.style.cursor = 'grab'; });
  canvas.addEventListener('pointermove', (e) => {
    if(!isPointerDown) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX; lastY = e.clientY;
    camRotY += dx * 0.005;
    camRotX += dy * 0.005;
    camRotX = Math.max(-1.2, Math.min(1.2, camRotX));
  });

  // Mode toggle
  let mode = "spiral";
  document.getElementById("toggle").addEventListener("click",()=>{
    mode = (mode==="spiral"?"rigid":"spiral");
    document.getElementById("toggle").textContent =
      "Mode: " + (mode==="spiral" ? "Spiral Spin" : "Rigid Spin");
  });

  let last = performance.now();
  function draw(now){
    const dt = now - last; last = now;
    const W = innerWidth, H = innerHeight;

    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);

    ctx.save();
    ctx.translate(W/2, H/2);

    const cosX = Math.cos(camRotX), sinX = Math.sin(camRotX);
    const cosY = Math.cos(camRotY), sinY = Math.sin(camRotY);

    for(const s of stars){
      if(mode==="rigid"){
        s.angle += params.spinSpeed * dt;  
      } else {
        s.angle += params.spinSpeed * dt * (0.5 + s.radius * 0.0005);
      }

      const x = Math.cos(s.angle) * s.radius;
      const y = Math.sin(s.angle) * s.radius;
      let z = s.z;

      let rx =  cosY * x + sinY * z;
      let rz = -sinY * x + cosY * z;
      let ry =  cosX * y - sinX * rz;
      rz =  sinX * y + cosX * rz;

      const denom = Math.max(120, CAMERA_DISTANCE + rz);
      const proj = CAMERA_DISTANCE / denom;

      const sx = rx * proj;
      const sy = ry * proj;
      const screenR = Math.max(0.18, s.size * proj);

      ctx.beginPath();
      ctx.fillStyle = s.color;
      ctx.arc(sx, sy, screenR, 0, Math.PI * 2);
      ctx.fill();
    }

    // Core glow
    const coreRadius = 22;
    const gradient = ctx.createRadialGradient(0,0,0,0,0,coreRadius*6);
    gradient.addColorStop(0,'rgba(255,255,220,1)');
    gradient.addColorStop(0.3,'rgba(255,220,180,0.6)');
    gradient.addColorStop(1,'rgba(255,200,200,0)');

    ctx.beginPath();
    ctx.fillStyle = gradient;
    ctx.arc(0,0, coreRadius*6, 0, Math.PI*2);
    ctx.fill();

    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,240,0.95)';
    ctx.arc(0,0, coreRadius, 0, Math.PI*2);
    ctx.fill();

    ctx.restore();
    requestAnimationFrame(draw);
  }

  requestAnimationFrame(draw);
})();
</script>
</body>
</html>
