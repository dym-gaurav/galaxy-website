<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Galaxy Preview (fixed)</title>
  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden;cursor:grab}
    canvas{display:block;width:100vw;height:100vh}

    #fullscreenBtn{
      position:fixed;
      bottom:15px;
      right:15px;
      z-index:10;
      background:#111a;
      border:none;
      border-radius:50%;
      width:44px;
      height:44px;
      display:flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
    }
    #fullscreenBtn:hover{ background:#333a; }
    #fullscreenBtn svg{ width:22px;height:22px;fill:#fff; }

    /* Leave a Star button */
    #leaveStarBtn{
      position:fixed;
      bottom:15px;
      left:15px;
      z-index:10;
      background:#ffd700aa;
      border:none;
      border-radius:20px;
      padding:10px 18px;
      font-size:14px;
      font-weight:bold;
      color:#000;
      cursor:pointer;
      box-shadow:0 0 8px #ffd70088;
    }
    #leaveStarBtn:hover{ background:#ffe066; }

    /* Toast notification */
    .toast {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 10px 20px;
      border-radius: 20px;
      font-weight: bold;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
      z-index: 100;
      opacity: 0;
      transition: opacity 0.3s;
    }

    /* Modal (non-blocking replacement for prompt) */
    .modal-overlay{
      position:fixed;inset:0;display:flex;align-items:center;justify-content:center;
      background:rgba(0,0,0,0.45);z-index:200;backdrop-filter:blur(3px);
    }
    .modal{background:#111;padding:18px;border-radius:12px;box-shadow:0 10px 30px rgba(0,0,0,0.6);color:#fff;min-width:280px}
    .modal h3{margin:0 0 8px 0;font-size:16px}
    .modal input{width:100%;padding:8px;border-radius:8px;border:1px solid #333;background:#0b0b0b;color:#fff;margin-bottom:10px}
    .modal .buttons{display:flex;gap:8px;justify-content:flex-end}
    .modal button{padding:8px 12px;border-radius:8px;border:none;cursor:pointer}
    .hidden{display:none}
  </style>
</head>
<body>
  <canvas id="c"></canvas>

  <!-- Fullscreen button -->
  <button id="fullscreenBtn" title="Toggle Fullscreen">
    <svg viewBox="0 0 24 24">
      <path d="M7 14H5v5h5v-2H7v-3zm-2-4h2V7h3V5H5v5zm12 7h-3v2h5v-5h-2v3zm-3-12v2h3v3h2V5h-5z"/>
    </svg>
  </button>

  <!-- Leave a Star button -->
  <button id="leaveStarBtn">Leave a Star ⭐</button>

  <!-- Non-blocking modal for name input -->
  <div id="nameModal" class="modal-overlay hidden" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true">
      <h3>Leave a Star — enter your name</h3>
      <input id="nameInput" placeholder="Your name" maxlength="40" />
      <div class="buttons">
        <button id="nameCancel">Cancel</button>
        <button id="nameOk">OK</button>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let DPR = Math.max(1, window.devicePixelRatio || 1);

  // === JSONbin Config ===
  const BIN_ID = "68bf1d83ae596e708fe72284"; // your bin id
  const API_KEY = "$2a$10$v5iz8EGzsG8zuskDmdWP3eVbYVF13tG.SWgu7BcmZ3rnawZ5WbnQC"; // NOTE: don't keep master key client-side in production
  const JSONBIN_URL = `https://api.jsonbin.io/v3/b/${BIN_ID}`;

  const LOCAL_KEY = 'galaxy.persistedStars.v1';

  const params = {
    spinSpeed: 0.00018,
    starCount: 1800,
    arms: 3,
    cameraDistanceFactor: 1.6,
    armTightness: 6.2,
    coreHeightFactor: 0.1,
    bgStarCount: 2000 // wallpaper stars
  };

  let CAMERA_DISTANCE = 1000;
  let stars = [];
  let persistedStars = [];

  function showToast(message) {
    const toast = document.createElement('div');
    toast.className = 'toast';
    toast.textContent = message;
    document.body.appendChild(toast);

    // Show toast
    requestAnimationFrame(() => {
      toast.style.opacity = 1;
    });

    // Hide toast after delay
    setTimeout(() => {
      toast.style.opacity = 0;
      setTimeout(() => {
        if (toast.parentNode) toast.parentNode.removeChild(toast);
      }, 300);
    }, 2500);
  }

  // --- DB functions with local fallback ---
  async function loadStarsFromDB(){
    // 1) Try localStorage first (fast)
    try{
      const local = localStorage.getItem(LOCAL_KEY);
      if(local){
        try{
          const parsed = JSON.parse(local);
          if(Array.isArray(parsed)){
            persistedStars = parsed;
            showToast('Loaded saved stars (local)');
          }
        }catch(e){ console.warn('local parse failed', e); }
      }
    }catch(e){ console.warn('localStorage read failed', e); }

    // 2) Then try remote (merge if available)
    try {
      const res = await fetch(JSONBIN_URL + '/latest', {
        headers: { 'X-Master-Key': API_KEY }
      });
      if(!res.ok) throw new Error('Remote load failed: ' + res.status);
      const data = await res.json();
      if(data && data.record && Array.isArray(data.record)){
        // Merge remote + local: remote takes precedence
        const map = new Map();
        (persistedStars || []).forEach(p => map.set(p.id, p));
        (data.record || []).forEach(p => map.set(p.id, p));
        persistedStars = Array.from(map.values());
        // also persist merged copy locally
        try{ localStorage.setItem(LOCAL_KEY, JSON.stringify(persistedStars)); }catch(e){ }
        showToast('Loaded saved stars (remote)');
      }
    } catch(err){ 
      console.warn('Failed to load stars from remote:', err);
      showToast('Could not load remote stars (using local)');
    }
  }

  // Debounced remote save to reduce requests
  let saveTimeout = null;
  function scheduleSaveStarsToDB(){
    if(saveTimeout) clearTimeout(saveTimeout);
    saveTimeout = setTimeout(() => saveStarsToDB(), 350);
  }

  async function saveStarsToDB(){
    // always update local copy first
    try{ localStorage.setItem(LOCAL_KEY, JSON.stringify(persistedStars)); }catch(e){ console.warn('local save failed', e); }

    // attempt remote save (best-effort — failures are OK)
    try {
      const res = await fetch(JSONBIN_URL, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json',
          'X-Master-Key': API_KEY
        },
        body: JSON.stringify(persistedStars)
      });
      if(!res.ok) throw new Error('Remote save failed: ' + res.status);
      showToast('Star saved (remote)');
    } catch(err){
      console.warn('Failed to save star remotely:', err);
      showToast('Saved locally (remote failed)');
    }
  }

  function resize(){
    DPR = Math.max(1, window.devicePixelRatio || 1);
    const W = innerWidth, H = innerHeight;
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR,0,0,DPR,0,0);

    CAMERA_DISTANCE = Math.max(W, H) * params.cameraDistanceFactor;
    regenerate();
  }
  addEventListener('resize', resize);
  resize();

  function regenerate(){
    stars = [];
    const W = innerWidth, H = innerHeight;
    const R = Math.hypot(W/2, H/2);

    // Spiral stars
    for(let i=0;i<params.starCount;i++){
      const arm = i % params.arms;
      const armAngle = (arm / params.arms) * Math.PI*2;
      const t = Math.random() * R * 0.85;
      const armOffset = -(t / R) * params.armTightness * Math.PI;
      const theta = armAngle + armOffset + (Math.random()-0.5)*0.15;
      const spread = Math.random() * 14 * (1 - t/R);

      const baseX = Math.cos(theta) * t + (Math.random()-0.5) * spread;
      const baseY = Math.sin(theta) * t + (Math.random()-0.5) * spread * 0.6;
      const baseZ = (Math.random() - 0.5) * Math.max(60, W*0.08) * params.coreHeightFactor;

      let size, color;
      if (Math.random() < 0.65) { 
        size = Math.max(0.6, (1 - t / R) * 2.8);
        const r = 120 + Math.floor(Math.random() * 60);
        const g = 120 + Math.floor(Math.random() * 60);
        const b = 180 + Math.floor(Math.random() * 40);
        const alpha = 0.6 + Math.random() * 0.4;
        color = `rgba(${r},${g},${b},${alpha.toFixed(3)})`;
      } else {
        size = Math.max(0.3, (1 - t / R) * 1.5);
        const r = 200 + Math.floor(Math.random() * 55);
        const g = 200 + Math.floor(Math.random() * 55);
        const b = 230 + Math.floor(Math.random() * 25);
        const alpha = 0.35 + Math.random() * 0.45;
        color = `rgba(${r},${g},${b},${alpha.toFixed(3)})`;
      }

      // Stable-ish ID
      const id = `spiral-${arm}-${t.toFixed(2)}-${theta.toFixed(2)}`;

      stars.push({ 
        id, 
        angle: theta, radius: t, x: baseX, y: baseY, z: baseZ, 
        size, color, arm, twinkle:false, name:null,
        burst:false, burstStart:0 
      });
    }

    // Background stars
    for(let i=0;i<params.bgStarCount;i++){
      const radius = Math.random() * R * 1.3;
      const angle = Math.random() * Math.PI * 2;
      const z = (Math.random() - 0.5) * Math.max(120, innerWidth*0.15);

      const size = 0.4 + Math.random() * 0.8;  
      const palette = [
        [220,220,255],[255,255,255],
        [255,245,200],[200,220,255]
      ];
      const c = palette[Math.floor(Math.random()*palette.length)];
      const baseAlpha = 0.45 + Math.random() * 0.45;

      const twinklePhase = Math.random() * Math.PI*2;
      const twinkleSpeed = 0.001 + Math.random() * 0.002;

      const id = `bg-${radius.toFixed(2)}-${angle.toFixed(2)}-${z.toFixed(2)}`;

      stars.push({ 
        id, 
        angle, radius, x:0, y:0, z, size, 
        color:[c[0],c[1],c[2]], baseAlpha, twinkle:true, 
        twinklePhase, twinkleSpeed, name:null,
        burst:false, burstStart:0
      });
    }

    // Apply persisted names to stars
    applyPersistedNames();
  }

  function applyPersistedNames(){
    if(!Array.isArray(persistedStars)) return;
    for(const ps of persistedStars){
      const s = stars.find(st => st.id === ps.id);
      if(s) s.name = ps.name;
    }
  }

  // Camera control
  let camRotX = -1.200;
  let camRotY = 2.810;
  let isPointerDown = false;
  let lastX = 0, lastY = 0;

  canvas.addEventListener('pointerdown', (e) => {
    isPointerDown = true;
    lastX = e.clientX; lastY = e.clientY;
    try{ canvas.setPointerCapture(e.pointerId); }catch(e){}
    canvas.style.cursor = 'grabbing';
  });
  canvas.addEventListener('pointerup', (e) => {
    isPointerDown = false;
    try { canvas.releasePointerCapture(e.pointerId); } catch(e){}
    canvas.style.cursor = 'grab';
  });
  canvas.addEventListener('pointercancel', () => { isPointerDown = false; canvas.style.cursor = 'grab'; });
  canvas.addEventListener('pointermove', (e) => {
    if(!isPointerDown) return;
    const dx = e.clientX - lastX;
    const dy = e.clientY - lastY;
    lastX = e.clientX; lastY = e.clientY;
    camRotY += dx * 0.005;
    camRotX += dy * 0.005;
    camRotX = Math.max(-1.2, Math.min(1.2, camRotX));
  });

  // Fullscreen button
  const fsBtn = document.getElementById("fullscreenBtn");
  fsBtn.addEventListener("click", () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(err => console.log(err));
    } else {
      document.exitFullscreen();
    }
  });

  // Name modal elements
  const nameModal = document.getElementById('nameModal');
  const nameInput = document.getElementById('nameInput');
  const nameOk = document.getElementById('nameOk');
  const nameCancel = document.getElementById('nameCancel');

  function openNameModal(){
    nameInput.value = '';
    nameModal.classList.remove('hidden');
    nameModal.setAttribute('aria-hidden', 'false');
    setTimeout(()=>nameInput.focus(),80);
  }
  function closeNameModal(){
    nameModal.classList.add('hidden');
    nameModal.setAttribute('aria-hidden', 'true');
  }

  // Leave a Star button behavior (non-blocking)
  const leaveStarBtn = document.getElementById('leaveStarBtn');
  leaveStarBtn.addEventListener('click', () => openNameModal());

  nameCancel.addEventListener('click', () => closeNameModal());
  nameOk.addEventListener('click', onNameOk);
  nameInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') onNameOk(); });

  function onNameOk(){
    const name = nameInput.value && nameInput.value.trim();
    if(!name){ showToast('Name cannot be empty'); return; }
    closeNameModal();

    try{
      const candidates = stars.filter(s => !s.twinkle && !s.name);
      if(candidates.length > 0){
        const chosen = candidates[Math.floor(Math.random()*candidates.length)];
        chosen.name = name;
        chosen.burst = true;
        chosen.burstStart = performance.now();

        const existingIndex = persistedStars.findIndex(ps => ps.id === chosen.id);
        if (existingIndex !== -1) {
          persistedStars[existingIndex].name = chosen.name;
        } else {
          persistedStars.push({ id: chosen.id, name: chosen.name });
        }

        // Save local + schedule remote save — do NOT block UI
        scheduleSaveStarsToDB();
      } else {
        showToast("No available stars to name!");
      }
    }catch(err){
      console.error('Failed to assign name', err);
      showToast('Something went wrong');
    }
  }

  // Draw loop with robust error handling so one exception doesn't stop animation
  let last = performance.now();
  function draw(now){
    try{
      const dt = now - last; last = now;
      const W = innerWidth, H = innerHeight;

      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,W,H);

      ctx.save();
      ctx.translate(W/2, H/2);

      const cosX = Math.cos(camRotX), sinX = Math.sin(camRotX);
      const cosY = Math.cos(camRotY), sinY = Math.sin(camRotY);

      for(const s of stars){
        try{
          s.angle += params.spinSpeed * dt * (0.5 + s.radius * 0.0005);

          const x = Math.cos(s.angle) * s.radius;
          const y = Math.sin(s.angle) * s.radius;
          let z = s.z || 0;

          let rx =  cosY * x + sinY * z;
          let rz = -sinY * x + cosY * z;
          let ry =  cosX * y - sinX * rz;
          rz =  sinX * y + cosX * rz;

          const denom = Math.max(120, CAMERA_DISTANCE + rz);
          const proj = CAMERA_DISTANCE / denom;

          const sx = rx * proj;
          const sy = ry * proj;
          let screenR = Math.max(0.18, (s.size || 0.5) * proj);

          let fillStyle;
          if(s.twinkle && Array.isArray(s.color)){
            const twinkle = 0.4 + 0.6 * Math.abs(Math.sin((s.twinklePhase||0) + now * (s.twinkleSpeed||0.001)));
            const alpha = Math.min(1, (s.baseAlpha||0.6) * twinkle);
            fillStyle = `rgba(${s.color[0]},${s.color[1]},${s.color[2]},${alpha.toFixed(3)})`;
          } else {
            fillStyle = s.color || 'rgba(220,220,255,0.8)';
          }

          // Burst effect
          if(s.burst){
            const elapsed = now - s.burstStart;
            if(elapsed < 1500){
              const pulse = 1 + 1.5 * Math.sin(elapsed/100 * Math.PI/6);
              screenR *= pulse;
              fillStyle = "rgba(255,215,0,0.95)";
            } else {
              s.burst = false;
            }
          }

          ctx.beginPath();
          ctx.fillStyle = fillStyle;
          ctx.arc(sx, sy, screenR, 0, Math.PI * 2);
          ctx.fill();

          // Name
          if(s.name){
            ctx.fillStyle = "#fff";
            ctx.font = "bold 12px sans-serif";
            ctx.textAlign = "center";
            ctx.fillText(s.name, sx, sy - 6);
          }
        }catch(err){
          // protect the main draw loop from any single-star errors
          console.warn('draw star error', err);
        }
      }

      // Core glow
      const coreRadius = 22;
      const gradient = ctx.createRadialGradient(0,0,0,0,0,coreRadius*6);
      gradient.addColorStop(0,'rgba(255,255,220,1)');
      gradient.addColorStop(0.3,'rgba(255,220,180,0.6)');
      gradient.addColorStop(1,'rgba(255,200,200,0)');

      ctx.beginPath();
      ctx.fillStyle = gradient;
      ctx.arc(0,0, coreRadius*6, 0, Math.PI*2);
      ctx.fill();

      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,255,240,0.95)';
      ctx.arc(0,0, coreRadius, 0, Math.PI*2);
      ctx.fill();

      ctx.restore();
    }catch(err){
      console.error('draw loop error', err);
    }finally{
      requestAnimationFrame(draw);
    }
  }

  // Initialize the application
  loadStarsFromDB().then(() => {
    regenerate();
    requestAnimationFrame(draw);
  });

})();
</script>
</body>
</html>
